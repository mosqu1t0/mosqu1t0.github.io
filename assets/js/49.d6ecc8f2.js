(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{315:function(t,a,v){"use strict";v.r(a);var s=v(10),_=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[t._v("#")]),t._v(" 方法")]),t._v(" "),a("p",[t._v("方法类似于函数")]),t._v(" "),a("ul",[a("li",[t._v("方法是解决一类问题的步骤的有序组合，用来完成特定功能的代码片段")]),t._v(" "),a("li",[t._v("方法包含于类或对象中")]),t._v(" "),a("li",[t._v("方法在程序中被创建，在其他地方被引用")])]),t._v(" "),a("p",[t._v("设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，就是一个方法只完成一个功能，这样有利于后期的扩展")]),t._v(" "),a("p",[t._v("方法包含一个"),a("strong",[t._v("方法头")]),t._v("和一个"),a("strong",[t._v("方法体")])]),t._v(" "),a("ul",[a("li",[t._v("修饰符：可选，告诉编译器如何调用该方法。定义了该方法的访问类型")]),t._v(" "),a("li",[t._v("返回值类型：returnValueTtpe")]),t._v(" "),a("li",[t._v("方法名")]),t._v(" "),a("li",[t._v("参数类型")]),t._v(" "),a("li",[t._v("方法体：具体的代码内容")])]),t._v(" "),a("h2",{attrs:{id:"方法调用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法调用"}},[t._v("#")]),t._v(" 方法调用")]),t._v(" "),a("ul",[a("li",[t._v("调用：对象名.方法名(实参列表)")]),t._v(" "),a("li",[t._v("java 支持两种调用方法的方式，根据方法是否返回值来选择\n"),a("ul",[a("li",[t._v("有返回值")]),t._v(" "),a("li",[t._v("无返回值")])])]),t._v(" "),a("li",[t._v("java 是值传递，传入方法的值会被拷贝")])]),t._v(" "),a("h2",{attrs:{id:"传参和返回"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传参和返回"}},[t._v("#")]),t._v(" 传参和返回")]),t._v(" "),a("p",[t._v("java传递参数，和返回 都是通过"),a("strong",[t._v("复制")]),t._v("的方式")]),t._v(" "),a("p",[t._v("参数和返回类型")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("基础类型")]),t._v(" "),a("ul",[a("li",[t._v("方法内无法修改"),a("strong",[t._v("普通")]),t._v("的基础类型变量，以及参数")])])]),t._v(" "),a("li",[a("p",[t._v("引用类型")]),t._v(" "),a("ul",[a("li",[t._v("方法可以通过复制传递引用的虚拟地址，指向堆中"),a("strong",[t._v("相同的内存")]),t._v("，但也仅仅能修改该内存，方法外的引用无法修改")])])])]),t._v(" "),a("h2",{attrs:{id:"方法的重载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法的重载"}},[t._v("#")]),t._v(" 方法的重载")]),t._v(" "),a("ul",[a("li",[t._v("重载就是在一个类中，有相同的名称，但形参不同的方法")]),t._v(" "),a("li",[t._v("方法的重载规则：\n"),a("ul",[a("li",[t._v("方法"),a("strong",[t._v("名称")]),t._v("必须"),a("strong",[t._v("相同")])]),t._v(" "),a("li",[a("strong",[t._v("参数")]),t._v("列表必须"),a("strong",[t._v("不同")]),t._v("(个数不同 或 类型不同 、参数排序顺序不同等)")]),t._v(" "),a("li",[t._v("方法的返回类型可以相同也可以不同")]),t._v(" "),a("li",[t._v("仅仅返回类型不同不足以成为方法的重载")])])]),t._v(" "),a("li",[t._v("理论：方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失效，则编译器报错")])]),t._v(" "),a("h2",{attrs:{id:"命令行传参"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命令行传参"}},[t._v("#")]),t._v(" 命令行传参")]),t._v(" "),a("p",[t._v("当需要运行一个程序时，再传递参数，需要依靠main()方法的 "),a("code",[t._v("String args[]")]),t._v("实现")]),t._v(" "),a("blockquote",[a("p",[t._v("javac  编译")])]),t._v(" "),a("h2",{attrs:{id:"可变参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可变参数"}},[t._v("#")]),t._v(" 可变参数")]),t._v(" "),a("ul",[a("li",[t._v("JDK1.5 开始，java支持传递同类型的可变参数给一个方法")]),t._v(" "),a("li",[t._v("在方法声明中，在指定参数类型后加一个省略号(...)")]),t._v(" "),a("li",[t._v("一个方法只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明")])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//i为数组")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"递归"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#递归"}},[t._v("#")]),t._v(" 递归")]),t._v(" "),a("p",[t._v("递归结构包含两个部分")]),t._v(" "),a("ul",[a("li",[t._v("递归头：什么时候不调用自身方法。如果没有头，将会陷入死循环。")]),t._v(" "),a("li",[t._v("递归体：什么时候需要调用自身方法。")])]),t._v(" "),a("blockquote",[a("p",[t._v("占用栈空间很多")])])])}),[],!1,null,null,null);a.default=_.exports}}]);